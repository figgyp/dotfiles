export class PackageJsonFile {
    constructor(filepath, fs) {
        this.filepath = filepath;
        this.fs = fs;
    }
    async parse() {
        const packageJsonContent = await this.fs.readFromFile(this.filepath);
        const packageJson = JSON.parse(packageJsonContent);
        return packageJson;
    }
    async persist(content) {
        const serializedPackageJson = JSON.stringify(content, null, 2);
        await this.fs.writeToFile(this.filepath, serializedPackageJson);
    }
    async getDetails() {
        const packageJson = await this.parse();
        const name = packageJson === null || packageJson === void 0 ? void 0 : packageJson.name;
        if (!name) {
            throw new Error(`Could not determine name in ${this.filepath}`);
        }
        const version = packageJson === null || packageJson === void 0 ? void 0 : packageJson.version;
        if (!version) {
            throw new Error(`Could not determine version in ${this.filepath}`);
        }
        const description = packageJson === null || packageJson === void 0 ? void 0 : packageJson.description;
        if (!description) {
            throw new Error(`Could not determine description in ${this.filepath}`);
        }
        return { name, version, description };
    }
    async containsDependency(packageName) {
        var _a, _b;
        try {
            const content = await this.parse();
            const dependencies = (_a = content["dependencies"]) !== null && _a !== void 0 ? _a : {};
            const devDpendencies = (_b = content["devDependencies"]) !== null && _b !== void 0 ? _b : {};
            const installedPackages = Object.keys(Object.assign(Object.assign({}, dependencies), devDpendencies));
            return installedPackages.includes(packageName);
        }
        catch (_c) {
            return false;
        }
    }
}
