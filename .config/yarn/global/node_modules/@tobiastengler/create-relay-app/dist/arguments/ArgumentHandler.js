import { program } from "commander";
export class ArgumentHandler {
    constructor(argumentDefinitions) {
        this.argumentDefinitions = argumentDefinitions;
    }
    async parseArgs(env) {
        const details = await env.ownPackageJson.getDetails();
        program.name(details.name).description(details.description).version(details.version, `-v, --version`);
        // Register CLI options.
        for (const argumentDefinition of this.argumentDefinitions) {
            argumentDefinition.registerCliOption(program);
        }
        program
            .option("--ignore-git-changes", "do not exit if the current directory has un-commited Git changes")
            .option("--skip-install", "skip the install of npm packages (only for testing)")
            .option(`-i, --interactive`, `display an interactive prompt that allows you to manually input your project's details`);
        // Parse CLI options.
        await program.parseAsync();
        const cliArgs = program.opts();
        this.validateArgs(cliArgs);
        return cliArgs;
    }
    async resolveMissingArgs(parsedArgs) {
        const allArgs = Object.assign({}, parsedArgs);
        for (const argumentDefinition of this.argumentDefinitions) {
            const existingValue = parsedArgs[argumentDefinition.name];
            if (existingValue !== undefined) {
                // Value was supplied as CLI argument, we don't need to prompt for it.
                argumentDefinition.submitWithValue(existingValue);
                continue;
            }
            if (parsedArgs.interactive) {
                const answer = await argumentDefinition.promptForValue(allArgs);
                // @ts-ignore
                allArgs[argumentDefinition.name] = answer;
            }
            else {
                // The user does not want to be prompted, so we choose default values.
                const defaultValue = await argumentDefinition.getDefaultValue(allArgs);
                argumentDefinition.submitWithValue(defaultValue);
                // @ts-ignore
                allArgs[argumentDefinition.name] = defaultValue;
            }
        }
        this.validateArgs(allArgs);
        return allArgs;
    }
    validateArgs(args) {
        for (const argumentDefinition of this.argumentDefinitions) {
            const value = args[argumentDefinition.name];
            if (value === undefined) {
                continue;
            }
            const successOrErrorReason = argumentDefinition.isValid(value, args);
            if (successOrErrorReason === true) {
                continue;
            }
            throw argumentDefinition.getInvalidArgError(value, undefined, successOrErrorReason);
        }
    }
}
